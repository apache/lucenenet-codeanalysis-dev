<?xml version="1.0" encoding="utf-8"?>

<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->

<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
  -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="LuceneDev1000_AnalyzerDescription" xml:space="preserve">
    <value>Floating point types should not be compared for exact equality.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1000_AnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' may fail due to JIT optimizations. Floating point types should not be compared for exact equality.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="LuceneDev1000_AnalyzerTitle" xml:space="preserve">
    <value>Floating point types should not be compared for exact equality</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1001_AnalyzerDescription" xml:space="preserve">
    <value>Floating point types should be formatted with J2N.Numerics.Single.ToString() or J2N.Numerics.Double.ToString().</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1001_AnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' may fail due to floating point precision issues on .NET Framework and .NET Core prior to version 3.0. Floating point types should be formatted with J2N.Numerics.Single.ToString() or J2N.Numerics.Double.ToString().</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="LuceneDev1001_AnalyzerTitle" xml:space="preserve">
    <value>Floating point types should be formatted with J2N Numerics Single or Double ToString methods</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1002_AnalyzerDescription" xml:space="preserve">
    <value>Floating point type arithmetic needs to be checked on x86 in .NET Framework.</value>
    <comment>An optional longer localizable description of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1002_AnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' may fail due to floating point precision issues on .NET Framework and .NET Core prior to version 3.0. Floating point type arithmetic needs to be checked on x86 in .NET Framework and may require extra casting.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="LuceneDev1002_AnalyzerTitle" xml:space="preserve">
    <value>Floating point type arithmetic needs to be checked on some x86 platforms</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1003_AnalyzerDescription" xml:space="preserve">
    <value>Method parameters that accept array types should be analyzed to determine whether they are better suited to be ref or out parameters.</value>
    <comment>Java is lacking ref and out parameters. As a result, code ported from Java may use parameters that accept a 1-dimensional array in order to facilitate returning a reference  to a value type. In .NET these hacks are unnecessary and these parameters should be converted to ref, out, or ValueTuple parameters.</comment>
  </data>
  <data name="LuceneDev1003_AnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' needs to be analyzed to determine whether the array can be replaced with a ref or out parameter</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="LuceneDev1003_AnalyzerTitle" xml:space="preserve">
    <value>Method parameters that accept array types should be analyzed to determine whether they are better suited to be ref or out parameters</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="LuceneDev1004_AnalyzerDescription" xml:space="preserve">
    <value>Methods that return array types should be analyzed to determine whether they are better suited to be one or more out parameters or to return a ValueTuple.</value>
    <comment>Java is lacking ref and out parameters. As a result, code ported from Java may use methods that return a 1-dimensional array in order to facilitate returning a reference to multiple value types. In .NET these hacks are unnecessary and these return values should be converted to out parameters or return a ValueTuple.</comment>
  </data>
  <data name="LuceneDev1004_AnalyzerMessageFormat" xml:space="preserve">
    <value>'{0}' return type needs to be analyzed to determine whether the array return value can be replaced with one or more out parameters or a return ValueTuple instead of an array to avoid the heap allocation</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="LuceneDev1004_AnalyzerTitle" xml:space="preserve">
    <value>Methods that return array types should be analyzed to determine whether they are better suited to be one or more out parameters or to return a ValueTuple</value>
    <comment>The title of the diagnostic.</comment>
  </data>
</root>
